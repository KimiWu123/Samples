const snarkjs = require("snarkjs");
const eddsa = require("circomlib/src/eddsa.js");
const mimcsponge = require("circomlib/src/mimcsponge.js")

const bigInt = snarkjs.bigInt;

const msg = "00010203040506070809"; // 10 bytes
const prvSeed = "0001020304050607080900010203040506070809000102030405060708090001";

function eddsa_jubjub_sign()
{
    const msgBig = bigInt("0x" + msg);
    // console.log("msg in bigint: ", msgBig);
    const hm = mimcsponge.multiHash([msgBig]);
    const hmBuff = bigInt.leInt2Buff(hm, 32);
    console.log("msg hash in bigint:\n ", hm, " --> msg");

    // private key of eddsa is generated by 32bytes seed. Some implementations 
    // use the seed as private key
    // https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
    const prvKey = Buffer.from(prvSeed, "hex");
    const pubKey = eddsa.prv2pub(prvKey);
    const signature = eddsa.sign(prvKey, hmBuff);
    console.log("public key:\n ", pubKey[0], " --> Ax")
    console.log(" ", pubKey[1], " --> Ay")
    console.log("signature:\n ", signature.R8[0], " --> R8x")
    console.log(" ", signature.R8[1], " --> R8y")
    console.log(" ", signature.S, " --> S")

    if(!eddsa.verify(hmBuff, signature, pubKey)){
        console.log("\nsignature not matched\n");
    }
}

eddsa_jubjub_sign()
